package handler

import (
	"sync/atomic"
	"time"
)

// Ticker manages periodic events using a time.Ticker
type Ticker struct {
	// Configuration for the ticker
	config *TickerConfig
	// Handler for processing ticker events
	tickerHandler TickerrHandler

	// Channel to signal ticker closure
	closeCh chan struct{}
	// Atomic boolean to check if ticker is closed
	closed atomic.Bool

	// Time ticker for generating periodic events
	ticker *time.Ticker
}

// Configuration settings for the ticker
type TickerConfig struct {
	Duration time.Duration // Duration between ticker events
}

// Creates a new TickerConfig with default values
func NewTickerConfig() *TickerConfig {
	c := &TickerConfig{}
	return c
}

// TickerEvent represents an event generated by the Ticker
type TickerEvent struct {
	CreateAt time.Time // Timestamp of event creation
}

// Interface for handling ticker events
type TickerrHandler interface {
	// Called when a ticker event is generated
	OnCall(e *TickerEvent)
}

// Creates a new Ticker instance
func NewTicker(handler TickerrHandler, config *TickerConfig) *Ticker {
	t := &Ticker{}

	t.config = config
	t.tickerHandler = handler

	t.closeCh = make(chan struct{})
	t.closed.Store(false)

	return t
}

// Starts the ticker and begins generating events
func (t *Ticker) Run() (err error) {
	defer t.Close()

	t.ticker = time.NewTicker(t.config.Duration)

	// Goroutine to handle ticker events and closure
	go func() {
		for {
			select {
			case <-t.ticker.C:
				// Generate a new ticker event and call the handler
				t.tickerHandler.OnCall(&TickerEvent{
					CreateAt: time.Now(),
				})
			case <-t.closeCh:
				return
			}
		}
	}()

	<-t.closeCh
	return nil
}

// Closes the ticker and stops generating events
func (t *Ticker) Close() {
	if t.closed.Load() {
		return
	}

	t.closed.Store(true)
	close(t.closeCh)
	t.ticker.Stop()
}
